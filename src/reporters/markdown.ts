import { ScanResult } from '../scanner';
import { Reporter } from './index';

export class MarkdownReporter implements Reporter {
  generate(result: ScanResult): string {
    const lines: string[] = [];
    
    // Header
    lines.push('# 🌱 Baseline Gardener Report');
    lines.push('');
    lines.push(`Generated on ${new Date().toISOString()}`);
    lines.push('');
    
    // Summary
    lines.push('## 📊 Summary');
    lines.push('');
    lines.push('| Metric | Value |');
    lines.push('|--------|-------|');
    lines.push(`| Files scanned | ${result.totalFiles} |`);
    lines.push(`| Total features detected | ${result.totalFeatures} |`);
    lines.push(`| Baseline compatible | ${result.baselineFeatures} |`);
    lines.push(`| Non-baseline features | ${result.nonBaselineFeatures} |`);
    lines.push('');
    
    // Feature breakdown
    lines.push('## 🎯 Feature Breakdown');
    lines.push('');
    lines.push('| Status | Count | Description |');
    lines.push('|--------|-------|-------------|');
    lines.push(`| 🟢 Widely available | ${result.summary.widely} | Safe to use in all modern browsers |`);
    lines.push(`| 🟡 Newly available | ${result.summary.newly} | Available in latest browsers |`);
    lines.push(`| 🔴 Limited availability | ${result.summary.limited} | Not baseline compatible |`);
    lines.push(`| ⚪ Unknown | ${result.summary.unknown} | Not found in baseline data |`);
    lines.push('');
    
    // Issues
    if (result.issues.length > 0) {
      lines.push('## ⚠️ Issues Found');
      lines.push('');
      
      const errorIssues = result.issues.filter(i => i.severity === 'error');
      const warningIssues = result.issues.filter(i => i.severity === 'warning');
      
      if (errorIssues.length > 0) {
        lines.push('### ❌ Errors');
        lines.push('');
        errorIssues.forEach(issue => {
          lines.push(this.formatIssue(issue));
          lines.push('');
        });
      }
      
      if (warningIssues.length > 0) {
        lines.push('### ⚠️ Warnings');
        lines.push('');
        warningIssues.forEach(issue => {
          lines.push(this.formatIssue(issue));
          lines.push('');
        });
      }
    } else {
      lines.push('## ✅ No Issues Found');
      lines.push('');
      lines.push('All detected features are baseline compatible!');
      lines.push('');
    }
    
    // Recommendations
    lines.push('## 💡 Recommendations');
    lines.push('');
    
    if (result.issues.length > 0) {
      if (result.issues.some(i => i.severity === 'error')) {
        lines.push('- Consider using polyfills for non-baseline features');
        lines.push('- Use progressive enhancement for experimental features');
        lines.push('- Check browser support requirements for your project');
      }
      
      if (result.summary.newly > 0) {
        lines.push('- Newly available features are generally safe but may not work in older browsers');
      }
      
      if (result.summary.limited > 0) {
        lines.push('- Limited availability features require careful consideration and testing');
      }
    } else {
      lines.push('- Your codebase is following baseline best practices!');
      lines.push('- Continue monitoring for new features as you develop');
    }
    
    lines.push('- Visit [web.dev/baseline](https://web.dev/baseline) for more information about baseline compatibility');
    lines.push('');
    
    // Footer
    lines.push('---');
    lines.push('');
    lines.push('Generated by [baseline-gardener](https://github.com/baseline-gardener/baseline-gardener)');
    
    return lines.join('\n');
  }
  
  private formatIssue(issue: any): string {
    const lines: string[] = [];
    
    lines.push(`#### \`${issue.feature}\``);
    lines.push('');
    lines.push(`**Message:** ${issue.message}`);
    lines.push('');
    
    if (issue.featureData?.spec) {
      lines.push(`**Specification:** [${issue.featureData.spec}](${issue.featureData.spec})`);
      lines.push('');
    }
    
    if (issue.featureData?.status?.support) {
      lines.push('**Browser Support:**');
      lines.push('');
      Object.entries(issue.featureData.status.support).forEach(([browser, version]: [string, any]) => {
        const icon = version ? '✅' : '❌';
        const versionText = version ? `${version}+` : 'Not supported';
        lines.push(`- ${icon} ${browser.charAt(0).toUpperCase() + browser.slice(1)}: ${versionText}`);
      });
      lines.push('');
    }
    
    lines.push(`**Locations:** (${issue.locations.length} found)`);
    lines.push('');
    
    // Show first few locations
    const locationsToShow = issue.locations.slice(0, 10);
    locationsToShow.forEach((location: any) => {
      const relativePath = location.location.file.replace(process.cwd(), '.');
      lines.push(`- \`${relativePath}:${location.location.line}:${location.location.column}\``);
      lines.push(`  \`\`\`${this.getLanguageFromType(location.type)}`);
      lines.push(`  ${location.code}`);
      lines.push('  ```');
    });
    
    if (issue.locations.length > 10) {
      lines.push(`- ... and ${issue.locations.length - 10} more locations`);
    }
    
    return lines.join('\n');
  }
  
  private getLanguageFromType(type: string): string {
    switch (type) {
      case 'js-api':
        return 'javascript';
      case 'css-property':
      case 'css-value':
      case 'css-selector':
        return 'css';
      case 'html-element':
        return 'html';
      default:
        return '';
    }
  }
}